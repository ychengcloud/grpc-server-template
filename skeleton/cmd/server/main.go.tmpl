package main

import (
	"context"
	"io/ioutil"
	"log"
	"net"
	"os"
	"strings"

	"google.golang.org/grpc"
	"google.golang.org/grpc/grpclog"

	"github.com/ychengcloud/fuxi/config"
	"{{ .Extra.pkgpath }}/database"
	"github.com/ychengcloud/fuxi/middleware"
	repogorm "{{ .Extra.pkgpath }}/repositories/gorm"
	"{{ .Extra.pkgpath }}/services"
	pb "{{ .Extra.protopkg }}/gen/go/{{ .Extra.package }}/v1"
)

var configFile = flag.String("c", "config", "set config file")

func main() {
	ctx := context.Background()
	cfg, err := config.New(*configFile, strings.ToUpper("{{ .Extra.servicename }}_"))
	if err != nil {
		log.Fatalln("Failed to listen:", err)

	}

	logger, err := NewLogger(&cfg.LoggerConfig)
	if err != nil {
		log.Fatalln("Failed to listen:", err)

	}

	db, err := database.NewGorm(ctx,
		database.WithMysqlHost(cfg.DatabaseConfig.MysqlOptions.Host),
		database.WithMysqlName(cfg.DatabaseConfig.MysqlOptions.Name),
		database.WithMysqlUser(cfg.DatabaseConfig.MysqlOptions.User),
		database.WithMysqlPassword(cfg.DatabaseConfig.MysqlOptions.Password),
	)
	if err != nil {
		log.Fatalf("failed create database: %s", err)
	}

	repo := repogorm.New{{ .Extra.servicename }}Repository(db)
	// Initialize the generated {{ .Extra.service }} service.
	svc := services.New{{ .Extra.servicename }}Service(repo)

	addr := net.JoinHostPort(cfg.AppConfig.Host, cfg.AppConfig.Port)
	gwAddr := net.JoinHostPort(cfg.AppConfig.GatewayHost, cfg.AppConfig.GatewayPort)
	lis, err := net.Listen("tcp", addr)
	if err != nil {
		log.Fatalln("Failed to listen:", err)
	}

	/// gRPC server statup options
	opts := []grpc.ServerOption{}

	// add middleware
	opts = middleware.AddLogging(logger, opts)

	s := grpc.NewServer(opts...)
	pb.Register{{ .Extra.servicename }}ServiceServer(s, svc)

	// Serve gRPC Server
	logger.Info("Serving gRPC on http://", zap.String("addr", addr))
	go func() {
		log.Fatal(s.Serve(lis))
	}()

	err = Run(gwAddr, "dns:///"+addr)
	log.Fatalln(err)
}
