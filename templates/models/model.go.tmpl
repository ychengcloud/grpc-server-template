{{- $extra := .Extra}}
{{- $modelNameLowerCamel := .NameLowerCamel}}
{{- $modelNameCamel := .NameCamel}}
// Code generated by hedone, DO NOT EDIT.

package models

import (
	"time"

{{ if eq $extra.primarykeytype "uuid" -}}
	"github.com/google/uuid"
{{- end }}
	"gorm.io/gorm"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"

	pb "{{ .Extra.protopkg }}/gen/go/{{ .Extra.package }}/v1"
)

type {{.NameCamel}} struct {
	{{- range .Fields}}
		{{- if not .IsRemote }}
			{{- $name := .NameCamel}}
			{{- $type := ""}}
			{{- $tags := (printf "json:\"%s\" gorm:\"%s" .NameLowerCamel .NameLowerCamel)}}
			{{- if eq .JoinType "None" }}
				{{- $type = .MetaType.GoType }}
			{{- end }}
			{{- if eq .JoinType "BelongTo" "HasOne" }}
				{{- $name = .NameCamel}}
				{{- $type = (printf "%s%s" "*" .RefTable.NameCamel)}}
			{{- end}}
			{{- if eq .JoinType "ManyToMany" "HasMany" }}
				{{- $name = .NameCamelPlural}}
				{{- $type = (printf "%s%s" "[]*" .RefTable.NameCamel)}}
				{{- $tags = (printf "json:\"%s\" gorm:\"%s" .NameLowerCamelPlural .NameLowerCamelPlural)}}
			{{- end}}
			{{- if .IsPrimaryKey }}
				{{- $tags = (printf "%s;primaryKey" $tags)}}
			{{- end}}
			{{- if .IsAutoIncrement }}
				{{- $tags = (printf "%s;autoIncrement" $tags)}}
			{{- end}}
			{{- if gt .MaxLength  0 }}
				{{- $tags = (printf "%s;size:%d" $tags .MaxLength)}}
			{{- end}}
			{{- if not (eq .JoinType "None") }}
				{{- $tags = (printf "%s;foreignKey:%s;references:%s" $tags (pascal .ForeignKey) (pascal .References))}}
			{{- end}}
			{{- if eq .JoinType "ManyToMany" }}
				{{- $tags = (printf "%s;many2many:%s;joinForeignKey:%s;joinReferences:%s" $tags .JoinTableName (pascal .JoinForeignKey) (pascal .JoinReferences)) }}
			{{- end}}
			{{- if not (eq .JoinType "None") }}
				{{- $tags = (printf "%s\" faker:\"-" $tags)}}
			{{- else}}
				{{- if and .IsPrimaryKey (eq $extra.primarykeytype "uuid") }}
					{{- $tags = (printf "%s\" faker:\"uuid_hyphenated" $tags)}}
				{{- end}}
			{{- end }}
			{{- $tags = (printf "%s\" %s" $tags .Tags)}}
			{{$name}} {{$type}} `{{$tags}}`
		{{- end}}
	{{- end}}
}

type {{.NameCamel}}FilterInput struct {
	NOT	*{{.NameCamel}}FilterInput `json:"NOT"`
	AND []*{{.NameCamel}}FilterInput `json:"AND"`
	OR	[]*{{.NameCamel}}FilterInput `json:"OR"`
	{{- range $index, $field := .Fields}}
		{{- if and (not .IsUnique) .IsIndex }}
			{{$field.NameCamel}} *{{$modelNameCamel}}Op{{$field.NameCamel}}Input `json:"{{$field.NameLowerCamel}}"`
		{{- end}}
	{{- end}}
}

{{- range .Fields}}
{{- if and (not .IsUnique) .IsIndex }}
	{{- $t := (printf "*%s" .MetaType.GoType) }}
	type {{$modelNameCamel}}Op{{.NameCamel}}Input struct {
		{{- range $index, $operation := ops . }}
			{{- if eq $operation "In" }}
				{{- $t = (printf "[]%s" $t) }}
			{{- end }}
			{{$operation}} {{$t}} `json:"{{$operation}}"`
		{{- end}}
	}
{{- end}}
{{- end}}

//TableName
func (m *{{.NameCamel}}) TableName() string {
	return "{{.Name}}"
}

func (m *{{.NameCamel}}) Valid() error {
	return validate.Struct(m)
}

func {{ .NameCamel }}ToORM({{.NameLowerCamel}} *pb.{{.NameCamel}}) *{{.NameCamel}} {
	m := &{{ .NameCamel }}{}
	{{- range .Fields}}
		{{- if eq .JoinType "None"}}
			m.{{.NameCamel}} = {{$modelNameLowerCamel}}.{{.NameCamel}}{{- if eq .MetaType.GoType "time.Time"}}.AsTime(){{- end}}
		{{- end}}
	{{- end}}

	{{- range .Fields}}
		{{- if not .IsRemote }}
			{{- if eq .JoinType "ManyToMany" "HasMany" }}
				{{.NameLowerCamelPlural}} := make([]*{{.RefTable.NameCamel}}, len({{$modelNameLowerCamel}}.{{.NameCamelPlural}}))
				for index, pb{{.NameCamel}} := range {{$modelNameLowerCamel}}.{{.NameCamelPlural}} {
					{{.NameLowerCamelPlural}}[index] = {{ .RefTable.NameCamel }}ToORM(pb{{.NameCamel}})
				}
				m.{{.NameCamelPlural}} = {{.NameLowerCamelPlural}}
			{{- end}}
			{{- if eq .JoinType "HasOne" "BelongTo" }}
				if {{$modelNameLowerCamel}}.{{.NameCamel}} != nil {
					m.{{.NameCamel}} = {{ .RefTable.NameCamel }}ToORM({{$modelNameLowerCamel}}.{{.NameCamel}})
				}
			{{- end}}
		{{- end}}
	{{- end}}
	
	return m
}

func (m *{{.NameCamel}}) ToPB() *pb.{{.NameCamel}} {
	{{- $modelNameCamel := .NameCamel}}
	{{- $modelNameLowerCamel := .NameLowerCamel}}
	pb{{$modelNameCamel}} := &pb.{{.NameCamel}}{
		{{- range .Fields}}
			{{- if eq .JoinType "None"}}
				{{- $value := "" }}
				{{- if eq .MetaType.GoType "time.Time"}}
					{{- $value = (printf "timestamppb.New(m.%s)" .NameCamel) }}
				{{- else }}
					{{- $value = (printf "m.%s" .NameCamel) }}
				{{- end }}
				{{.NameCamel}}:     {{ $value }},
			{{- end}}
		{{- end}}
	}

	{{- range .Fields}}
		{{- if not .IsRemote }}
			{{- if eq .JoinType "ManyToMany" "HasMany" }}
				pb{{.NameCamelPlural}} := make([]*pb.{{.RefTable.NameCamel}} , 0, len(m.{{.NameCamelPlural}}))
				for _, {{.NameLowerCamel}} := range m.{{.NameCamelPlural}} {
					pb{{.NameCamelPlural}} = append(pb{{.NameCamelPlural}}, {{.NameLowerCamel}}.ToPB())
				}
				pb{{$modelNameCamel}}.{{.NameCamelPlural}} = pb{{.NameCamelPlural}}
			{{- end}}
			{{- if or (eq .JoinType "HasOne") (eq .JoinType "BelongTo") }}
				if m.{{.NameCamel}} != nil {
					pb{{$modelNameCamel}}.{{.NameCamel}} = m.{{.NameCamel}}.ToPB()
				}
			{{- end}}
		{{- end}}
	{{- end}}
	return pb{{$modelNameCamel}}
}

{{ if eq $extra.primarykeytype "uuid" -}}
	func (m *{{.NameCamel}}) BeforeCreate(tx *gorm.DB) (err error) {
		if m.Id != "" {
			_, err := uuid.Parse(m.Id)
			if err != nil {
				return status.Errorf(codes.InvalidArgument, "invalid argument")
			}
			return nil
		}
		m.Id = uuid.New().String()
		return
	}
{{- end}}
