{{- $model := .}}
{{- $hasParentResource := false}}
{{- $hasFilter := false}}
{{- $parentFieldIndex := 0 }}
{{- $filterFieldIndex := 0}}

{{- range $i, $field := .Fields}}
	{{- if not $hasParentResource }}
		{{- if eq $field.JoinType "BelongTo" "ManyToMany" }}
			{{- $hasParentResource = true}}
			{{- $parentFieldIndex = $i }}
		{{- end}}
	{{- end}}
	{{- if not $hasFilter }}
		{{- if and (not $field.IsUnique) $field.IsIndex }}
			/*只生成string 类型的filter 测试代码*/
			{{- if eq $field.MetaType.GoType "string" }}
				{{- $hasFilter = true}}
				{{- $filterFieldIndex = $i }}
			{{- end}}
		{{- end}}
	{{- end}}
{{- end}}

// Code generated by hedone, DO NOT EDIT.
package repogorm

import (
	"context"
	"fmt"
	"testing"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/bxcodec/faker/v3"
	"github.com/google/uuid"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	{{- if $hasFilter }}
		wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	{{- end}}

	"github.com/ychengcloud/fuxi/models"
	{{ if $hasFilter -}}
		pb "github.com/ychengcloud/proto/gen/go/fuxi/v1"
	{{- end }}
)

//TODO: Add more test case
func TestList{{ $model.NameCamelPlural }}(t *testing.T) {
	sqlDB, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer sqlDB.Close()
	db, err := gorm.Open(mysql.New(mysql.Config{
		Conn:                      sqlDB,
		SkipInitializeWithVersion: true,
	}), &gorm.Config{
		DisableAutomaticPing: true,
	})

	{{- if $hasFilter }}
		{{- $field := index .Fields $filterFieldIndex }}
		{{ $field.NameLowerCamel }} := wrapperspb.StringValue{Value: "1"}
		{{ $field.NameLowerCamel }}2 := wrapperspb.StringValue{Value: "2"}
		filter := &pb.{{ $model.NameCamel }}FilterInput{
			{{ $field.NameCamel }}: &pb.{{ $model.NameCamel }}Op{{ $field.NameCamel }}Input{
				Eq: &{{ $field.NameLowerCamel }},
			},
			NOT: &pb.{{ $model.NameCamel }}FilterInput{
				{{ $field.NameCamel }}: &pb.{{ $model.NameCamel }}Op{{ $field.NameCamel }}Input{
					Eq: &{{ $field.NameLowerCamel }},
				},
			},
			AND: []*pb.{{ $model.NameCamel }}FilterInput{
				{
					{{ $field.NameCamel }}: &pb.{{ $model.NameCamel }}Op{{ $field.NameCamel }}Input{
						Eq: &{{ $field.NameLowerCamel }},
					},
				},
				{
					{{ $field.NameCamel }}: &pb.{{ $model.NameCamel }}Op{{ $field.NameCamel }}Input{
						Eq: &{{ $field.NameLowerCamel }}2,
					},
				},
			},
			OR: []*pb.{{ $model.NameCamel }}FilterInput{
				{
					{{ $field.NameCamel }}: &pb.{{ $model.NameCamel }}Op{{ $field.NameCamel }}Input{
						Eq: &{{ $field.NameLowerCamel }},
					},
				},
				{
					{{ $field.NameCamel }}: &pb.{{ $model.NameCamel }}Op{{ $field.NameCamel }}Input{
						Eq: &{{ $field.NameLowerCamel }}2,
					},
				},
			},
		}
	{{- end}}

	results := []struct {
		parent  string
		filter  *pb.{{ $model.NameCamel }}FilterInput
		orderBy string
		count   int32
		token   string
		before  func(sqlmock.Sqlmock)
		wantErr bool
	}{
		{
			parent: "",
			filter: nil,
			before: func(mock sqlmock.Sqlmock) {
				query := fmt.Sprintf("SELECT count(*) FROM `{{ $model.NameSnake }}` LIMIT %d", MaxLimit+1)
				mock.ExpectQuery(escape(query)).WillReturnRows(sqlmock.NewRows([]string{"10"}))
				query = fmt.Sprintf("SELECT * FROM `{{ $model.NameSnake }}` LIMIT %d", MaxLimit+1)
				mock.ExpectQuery(escape(query)).WillReturnRows(sqlmock.NewRows([]string{"10"}))
			},
		},
		{{- if $hasParentResource }}
		{{- $field := index .Fields $parentFieldIndex }}
			{{- if eq $field.JoinType "ManyToMany" }}
				{
					parent: "{{ $field.NameLowerCamelPlural }}/1",
					filter: nil,
					before: func(mock sqlmock.Sqlmock) {
						query := fmt.Sprintf("SELECT {{ $field.JoinForeignKey }} FROM `{{ $field.JoinTableName }}` WHERE {{ $field.JoinReferences }} = ?")
				mock.ExpectQuery(escape(query)).WithArgs("1").WillReturnRows(sqlmock.NewRows([]string{"{{ $field.JoinForeignKey }}"}).AddRow("10"))
						query = fmt.Sprintf("SELECT count(*) FROM `{{ $model.NameSnake }}` WHERE {{ $field.ForeignKey }} IN (?) LIMIT %d", MaxLimit+1)
				mock.ExpectQuery(escape(query)).WithArgs("10").WillReturnRows(sqlmock.NewRows([]string{"count"}).AddRow(1))
						query = fmt.Sprintf("SELECT * FROM `{{ $model.NameSnake }}` WHERE {{ $field.ForeignKey }} IN (?) LIMIT %d", MaxLimit+1)
						mock.ExpectQuery(escape(query)).WithArgs("10").WillReturnRows(sqlmock.NewRows([]string{}))
					},
				},
			{{- else }}
				{
					parent: "{{ $field.NameLowerCamelPlural }}/1",
					filter: nil,
					before: func(mock sqlmock.Sqlmock) {
						query := fmt.Sprintf("SELECT count(*) FROM `{{ $model.NameSnake }}` WHERE {{ $field.ForeignKey }} = ? LIMIT %d", MaxLimit+1)
						mock.ExpectQuery(escape(query)).WithArgs("1").WillReturnRows(sqlmock.NewRows([]string{"10"}))
						query = fmt.Sprintf("SELECT * FROM `{{ $model.NameSnake }}` WHERE {{ $field.ForeignKey }} = ? LIMIT %d", MaxLimit+1)
						mock.ExpectQuery(escape(query)).WithArgs("1").WillReturnRows(sqlmock.NewRows([]string{"10"}))
					},
				},
			{{- end }}
		{{- end}}
		{{- if $hasFilter }}
		{{- $field := index .Fields $filterFieldIndex }}
			{
				parent: "",
				filter: filter,
				before: func(mock sqlmock.Sqlmock) {
					query := fmt.Sprintf("SELECT count(*) FROM `{{ $model.NameSnake }}` WHERE (`{{ $field.NameSnake }}` = ? AND `{{ $field.NameSnake }}` <> ? AND (`{{ $field.NameSnake }}` = ? OR `{{ $field.NameSnake }}` = ?) AND (`{{ $field.NameSnake }}` = ? AND `{{ $field.NameSnake }}` = ?)) LIMIT %d", MaxLimit+1)
					mock.ExpectQuery(escape(query)).WithArgs("1", "1", "1", "2", "1", "2").WillReturnRows(sqlmock.NewRows([]string{"10"}))
					query = fmt.Sprintf("SELECT * FROM `{{ $model.NameSnake }}` WHERE (`{{ $field.NameSnake }}` = ? AND `{{ $field.NameSnake }}` <> ? AND (`{{ $field.NameSnake }}` = ? OR `{{ $field.NameSnake }}` = ?) AND (`{{ $field.NameSnake }}` = ? AND `{{ $field.NameSnake }}` = ?)) LIMIT %d", MaxLimit+1)
					mock.ExpectQuery(escape(query)).WithArgs("1", "1", "1", "2", "1", "2").WillReturnRows(sqlmock.NewRows([]string{"10"}))

				},
			},
		{{- end}}
	}

	for idx, result := range results {
		t.Run(fmt.Sprintf("case #%v", idx), func(t *testing.T) {
			result.before(mock)
			repo := &repository{db: db}
			ctx := context.Background()
			_, _, _, err := repo.List{{ $model.NameCamelPlural }}(ctx, result.parent, result.filter, result.orderBy, result.count, result.token)
			if err != nil {
				t.Fatalf("an error '%s' was not expected while {{ $model.NameCamel }}", err)
			}
			if err := mock.ExpectationsWereMet(); err != nil {
				t.Errorf("there were unfulfilled expectations: %s", err)
			}

		})
	}
}

func TestCreate{{ $model.NameCamel }}(t *testing.T) {
	sqlDB, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer sqlDB.Close()
	db, err := gorm.Open(mysql.New(mysql.Config{
		Conn:                      sqlDB,
		SkipInitializeWithVersion: true,
	}), &gorm.Config{
		DisableAutomaticPing: true,
	})

	testModel := &models.{{ $model.NameCamel }}{}
	faker.FakeData(&testModel)

	results := []struct {
		model 	*models.{{ $model.NameCamel }}
		before  func(sqlmock.Sqlmock, *models.{{ $model.NameCamel }})
		wantErr bool
	}{
		{
			model: testModel,
			before: func(mock sqlmock.Sqlmock, model *models.{{ $model.NameCamel }}) {
				mock.ExpectBegin()
				insertSql := fmt.Sprintf("INSERT INTO `{{ $model.NameSnake }}`")
				mock.ExpectExec(insertSql).WithArgs(
			{{- range $field := .Fields -}}
				{{- if eq $field.JoinType "None" -}}
					{{- if .IsPrimaryKey -}}
						AnyUUID{},
					{{- else -}}
						{{- if eq .NameCamel "CreatedAt" "UpdatedAt" -}}
							AnyTime{},
						{{- else -}}
							model.{{- $field.NameCamel -}},
						{{- end -}}
					{{- end -}}
				{{- end -}}
			{{- end -}}
				).WillReturnResult(sqlmock.NewResult(1, 1))
				mock.ExpectCommit()
			},
		},
	}

	for idx, result := range results {
		t.Run(fmt.Sprintf("case #%v", idx), func(t *testing.T) {
			result.before(mock, result.model)
			repo := &repository{db: db}
			ctx := context.Background()
			_, err := repo.Create{{ $model.NameCamel }}(ctx, result.model)
			if err != nil {
				t.Fatalf("an error '%s' was not expected while {{ $model.NameCamel }}", err)
			}
			if err := mock.ExpectationsWereMet(); err != nil {
				t.Errorf("there were unfulfilled expectations: %s", err)
			}

		})
	}
}

func TestUpdate{{ $model.NameCamel }}(t *testing.T) {
	sqlDB, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer sqlDB.Close()
	db, err := gorm.Open(mysql.New(mysql.Config{
		Conn:                      sqlDB,
		SkipInitializeWithVersion: true,
	}), &gorm.Config{
		DisableAutomaticPing: true,
	})

	testModel := &models.{{ $model.NameCamel }}{}
	faker.FakeData(&testModel)

	results := []struct {
		model 	*models.{{ $model.NameCamel }}
		before  func(sqlmock.Sqlmock, *models.{{ $model.NameCamel }})
		wantErr bool
	}{
		{
			model: testModel,
			before: func(mock sqlmock.Sqlmock, model *models.{{ $model.NameCamel }}) {
				mock.ExpectBegin()
				updateSql := fmt.Sprintf("UPDATE `{{ $model.Name }}` SET (.+) WHERE `{{$model.PrimaryKeyField.NameSnake}}` = ?")
				mock.ExpectExec(updateSql).WithArgs(
			{{- range $field := .Fields -}}
				{{- if eq $field.JoinType "None" -}}
					{{- if not .IsPrimaryKey -}}
						{{- if eq .NameCamel "CreatedAt" "UpdatedAt" -}}
							AnyTime{},
						{{- else -}}
							model.{{- $field.NameCamel -}},
						{{- end -}}
					{{- end -}}
				{{- end -}}
			{{- end -}}
				AnyUUID{},).WillReturnResult(sqlmock.NewResult(1, 1))
				mock.ExpectCommit()
			},
		},
	}

	for idx, result := range results {
		t.Run(fmt.Sprintf("case #%v", idx), func(t *testing.T) {
			result.before(mock, result.model)
			repo := &repository{db: db}
			ctx := context.Background()
			_, err := repo.Update{{ $model.NameCamel }}(ctx, result.model)
			if err != nil {
				t.Fatalf("an error '%s' was not expected while {{ $model.NameCamel }}", err)
			}
			if err := mock.ExpectationsWereMet(); err != nil {
				t.Errorf("there were unfulfilled expectations: %s", err)
			}

		})
	}
}

func TestDelete{{ $model.NameCamel }}(t *testing.T) {
	sqlDB, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer sqlDB.Close()
	db, err := gorm.Open(mysql.New(mysql.Config{
		Conn:                      sqlDB,
		SkipInitializeWithVersion: true,
	}), &gorm.Config{
		DisableAutomaticPing: true,
	})

	testModel := &models.{{ $model.NameCamel }}{}
	faker.FakeData(&testModel)

	results := []struct {
		model 	*models.{{ $model.NameCamel }}
		before  func(sqlmock.Sqlmock, *models.{{ $model.NameCamel }})
		wantErr bool
	}{
		{
			model: testModel,
			before: func(mock sqlmock.Sqlmock, model *models.{{ $model.NameCamel }}) {
				mock.ExpectQuery(escape("SELECT `{{$model.PrimaryKeyField.NameSnake}}` FROM `{{ $model.Name }}` WHERE `{{$model.PrimaryKeyField.NameSnake}}` = ? ORDER BY `{{ $model.Name }}`.`{{$model.PrimaryKeyField.NameSnake}}` LIMIT 1")).WillReturnRows(sqlmock.NewRows([]string{
				"{{$model.PrimaryKeyField.NameSnake}}"}).AddRow(model.{{$model.PrimaryKeyField.NameCamel}}))
				mock.ExpectBegin()
				deleteSql := fmt.Sprintf("DELETE FROM `{{ $model.Name }}` WHERE `{{ $model.Name }}`.`{{$model.PrimaryKeyField.NameSnake}}` = ?")
				mock.ExpectExec(deleteSql).WithArgs(AnyUUID{}).WillReturnResult(sqlmock.NewResult(1, 1))
				mock.ExpectCommit()
			},
		},
	}

	for idx, result := range results {
		t.Run(fmt.Sprintf("case #%v", idx), func(t *testing.T) {
			result.before(mock, result.model)
			repo := &repository{db: db}
			ctx := context.Background()
			_, err := repo.Delete{{ $model.NameCamel }}(ctx, result.model.{{$model.PrimaryKeyField.NameCamel }})
			if err != nil {
				t.Fatalf("an error '%s' was not expected while {{ $model.NameCamel }}", err)
			}
			if err := mock.ExpectationsWereMet(); err != nil {
				t.Errorf("there were unfulfilled expectations: %s", err)
			}

		})
	}
}