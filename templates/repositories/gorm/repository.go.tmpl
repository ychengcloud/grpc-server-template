// Code generated by hedone, DO NOT EDIT.
package repogorm

import (
	"context"
	"errors"
	"strconv"
	"strings"

	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"

	"{{ .Extra.pkgpath }}/database"
	pb "{{ .Extra.protopkg }}/gen/go/{{ .Extra.package }}/v1"
	"{{ .Extra.pkgpath }}/models"
)
{{- $tableNameCamel := .NameCamel}}
{{- $primaryKeyField := .PrimaryKeyField}}
{{- $hasParentResource := false}}

{{- range .Fields}}
{{- if eq .JoinType "BelongTo" "ManyToMany" }}
	{{- $hasParentResource = true}}
{{- end}}
{{- end}}

func (r *repository) List{{.NameCamelPlural}}(ctx context.Context, parent string, filter *pb.{{ .NameCamel }}FilterInput, orderBy string, count int32, token string) ({{.NameLowerCamelPlural}} []*models.{{.NameCamel}}, nextToken string, totalCount int64, err error) {
	db := r.db

	exprs := make([]clause.Expression, 0)

	{{- if $hasParentResource }}
		db, err = apply{{.NameCamel}}Parent(db, parent)
		if err != nil {
			return
		}
	{{- end}}

	limit := int(count)
	if limit == 0 {
		limit = MaxLimit
	}
	if token == "" {
		token = "0"
	}

	offset, err := strconv.Atoi(token)
	if err != nil {
		return
	}

	{{.NameLowerCamelPlural}} = make([]*models.{{.NameCamel}}, 0)

	if strings.TrimSpace(orderBy) != "" {
		db = db.Order(orderBy)
	}

	db = db.Limit(limit + 1)
	db = db.Offset(offset)

	filterExpression, err := apply{{.NameCamel}}Filter(filter)
	if err != nil {
		return
	}
	if filterExpression != nil {
		exprs = append(exprs, filterExpression)
	}
	if len(exprs) > 0 {
		where := clause.Where{Exprs: exprs}
		db = db.Clauses(where)
	}

	err = db.Model(&models.{{.NameCamel}}{}).Count(&totalCount).Error
	if err != nil {
		return
	}

	err = db.Find(&{{.NameLowerCamelPlural}}).Error

	if err != nil {
		return
	}

	return
}

func (r *repository) Create{{.NameCamel}}(ctx context.Context, {{.NameLowerCamel}} *models.{{.NameCamel}}) (*models.{{.NameCamel}}, error) {
	if {{.NameLowerCamel}} == nil {
		return nil, status.Errorf(codes.InvalidArgument, "invalid argument: {{$primaryKeyField.NameLowerCamel}} is not provided")
	}

	var err error
	tx := r.db.Begin()
	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	if err = tx.Create({{.NameLowerCamel}}).Error; err != nil {
		return nil, err
	}

	switch {
	case err == nil:
		tx.Commit()
		return {{.NameLowerCamel}}, nil
	case database.IsUniqueConstraintError(err):
		return nil, status.Errorf(codes.AlreadyExists, "already exists: %s", err)
	case errors.Is(err, gorm.ErrInvalidField):
		return nil, status.Errorf(codes.InvalidArgument, "invalid argument: %s", err)
	default:
		return nil, status.Errorf(codes.Internal, "internal: %s", err)
	}
}

func (r *repository) get{{ $tableNameCamel }}(ctx context.Context, field string, value interface{}, withEdges bool) (*models.{{ $tableNameCamel }}, error) {
	if field == "" {
		return nil, status.Errorf(codes.InvalidArgument, "invalid argument: id is not provided")
	}

	var (
		err   error
		model models.{{ $tableNameCamel }}
	)

	db := r.db.Session(&gorm.Session{})

	if withEdges {
		db = db.Preload(clause.Associations)
	}

	err = db.Model(&model).Where("? = ?", field, value).First(&model).Error

	switch {
	case err == nil:
		return &model, nil
	case errors.Is(err, gorm.ErrRecordNotFound):
		return nil, status.Errorf(codes.NotFound, "not found: %s", err)
	default:
		return nil, status.Errorf(codes.Internal, "internal error: %s", err)
	}
}

{{- range .Fields}}
{{- if or .IsPrimaryKey .IsUnique }}
	func (r *repository) Get{{ $tableNameCamel }}By{{ .NameCamel }}(ctx context.Context, {{ .NameLowerCamel }} string, withEdges bool) (*models.{{ $tableNameCamel }}, error) {
		return r.get{{ $tableNameCamel }}(ctx, "{{ .NameSnake }}", {{ .NameLowerCamel }}, withEdges)
	}
{{- end}}
{{- end}}

func (r *repository) Update{{.NameCamel}}(ctx context.Context, {{.NameLowerCamel}} *models.{{.NameCamel}}) (*models.{{.NameCamel}}, error) {

	if {{.NameLowerCamel}} == nil || {{.NameLowerCamel}}.{{$primaryKeyField.NameCamel}} == "" {
		return nil, status.Errorf(codes.InvalidArgument, "invalid argument: {{$primaryKeyField.NameLowerCamel}} is not provided")
	}

	var err error
	tx := r.db.Begin()
	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	if err = tx.Updates({{.NameLowerCamel}}).Error; err != nil {
		return nil, err
	}

	switch {
	case err == nil:
		tx.Commit()
		return {{.NameLowerCamel}}, nil
	case database.IsUniqueConstraintError(err):
		return nil, status.Errorf(codes.AlreadyExists, "already exists: %s", err)
	case errors.Is(err, gorm.ErrInvalidField):
		return nil, status.Errorf(codes.InvalidArgument, "invalid argument: %s", err)
	default:
		return nil, status.Errorf(codes.Internal, "internal: %s", err)
	}
}

func (r *repository) Delete{{.NameCamel}}(ctx context.Context, {{$primaryKeyField.NameLowerCamel}} string) (*models.{{.NameCamel}}, error) {

	if {{$primaryKeyField.NameLowerCamel}} == "" {
		return nil, status.Errorf(codes.InvalidArgument, "invalid argument: {{$primaryKeyField.NameLowerCamel}} is not provided")
	}

	db := r.db
	var err error

	{{.NameLowerCamel}} := &models.{{.NameCamel}}{}
	err = db.Model(&{{.NameLowerCamel}}).Select("`{{$primaryKeyField.NameSnake}}`").Where("`{{$primaryKeyField.NameSnake}}` = ?", {{$primaryKeyField.NameLowerCamel}}).First(&{{.NameLowerCamel}}).Error
	switch {
	case err == nil:
	case errors.Is(err, gorm.ErrRecordNotFound):
		return nil, status.Errorf(codes.NotFound, "not found: %s", err)
	default:
		return nil, status.Errorf(codes.Internal, "internal error: %s", err)
	}

	tx := db.Begin()
	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	err = tx.Delete({{.NameLowerCamel}}).Error

	switch {
	case err == nil:
		tx.Commit()
		return {{.NameLowerCamel}}, nil
	default:
		return nil, status.Errorf(codes.Internal, "internal error: %s", err)
	}
}


// 处理  过滤条件
// op 取值 OR, AND, NOT
func apply{{ .NameCamel }}Filter(filterInput *pb.{{ .NameCamel }}FilterInput) (clause.Expression, error) {
	var exprs []clause.Expression
	if filterInput == nil {
		return nil, nil
	}

	{{- range .Fields}}
	{{- $field := .}}
	{{- if and (not .IsUnique) .IsIndex }}
	if filterInput.{{ $field.NameCamel }} != nil {
		{{- range .Operations }}
			if filterInput.{{ $field.NameCamel }}.Get{{ . }}() != nil {
				exprs = append(exprs, clause.{{ . }}{
				Column: "{{ $field.NameSnake }}",
				Value:  filterInput.{{ $field.NameCamel }}.Get{{ . }}().GetValue(),
			})
			}
		{{- end }}
	}
	{{- end}}
	{{- end}}

	if filterInput.NOT != nil {
		e, err := apply{{ .NameCamel }}Filter(filterInput.NOT)
		if err != nil {
			return nil, err
		}
		exprs = append(exprs, clause.Not(e))
	}

	if filterInput.OR != nil {
		switch n := len(filterInput.OR); {
		case n == 1:
			e, err := apply{{ .NameCamel }}Filter(filterInput.OR[0])
			if err != nil {
				return nil, err
			}
			exprs = append(exprs, e)
		case n > 1:
			or := make([]clause.Expression, 0, n)
			for _, w := range filterInput.OR {
				e, err := apply{{ .NameCamel }}Filter(w)
				if err != nil {
					return nil, err
				}
				or = append(or, e)
			}
			exprs = append(exprs, clause.Or(or...))
		}
	}

	if filterInput.AND != nil {
		switch n := len(filterInput.AND); {
		case n == 1:
			e, err := apply{{ .NameCamel }}Filter(filterInput.AND[0])
			if err != nil {
				return nil, err
			}
			exprs = append(exprs, e)
		case n > 1:
			and := make([]clause.Expression, 0, n)
			for _, w := range filterInput.AND {
				e, err := apply{{ .NameCamel }}Filter(w)
				if err != nil {
					return nil, err
				}
				and = append(and, e)
			}
			exprs = append(exprs, clause.And(and...))
		}
	}

	switch len(exprs) {
	case 0:
		return nil, fmt.Errorf("empty apply{{ .NameCamel }}Filter")
	case 1:
		return exprs[0], nil
	default:
		return clause.And(exprs...), nil
	}
}

{{- if $hasParentResource }}
	func apply{{ .NameCamel }}Parent(db *gorm.DB, parent string) (*gorm.DB, error) {
		if parent == "" {
			return db, nil
		}
		parentPair := strings.Split(parent, "/")
		if len(parentPair) != 2 {
			return nil, status.Errorf(codes.InvalidArgument, "Invalid parent resource name: %s", parent)
		}

		parentName := parentPair[0]
		parentId := parentPair[1]
		if strings.TrimSpace(parentName) == "" || strings.TrimSpace(parentId) == "" {
			return nil, status.Errorf(codes.InvalidArgument, "Invalid parent resource name: %s", parent)
		}

		switch parentName {
	{{- range .Fields}}
	{{- if eq .JoinType "BelongTo" }}
		case "{{ .NameLowerCamelPlural }}":
			return db.Where("{{ .ForeignKey }} = ?", parentId), nil
	{{- end}}
	{{- if eq .JoinType "ManyToMany" }}
		case "{{ .NameLowerCamelPlural }}":
		ids := make([]string, 0)
		joinDB := db.Session(&gorm.Session{})
		err := joinDB.Select("{{ .JoinForeignKey }}").Table("{{ .JoinTableName }}").Where("{{ .JoinReferences }} = ?", parentId).Find(&ids).Error
		if err != nil {
			return nil, err
		}
		return db.Where("id IN (?)", ids), nil
	{{- end}}
	{{- end}}
		default:
			return nil, status.Errorf(codes.InvalidArgument, "Unsupported parent resource name: %s", parent)
		}

	}
{{- end}}
